//----------------------------------------------------------------------
// NavBit.h:
//   Implementation of navigation bit synthesis base class
//
//          Copyright (C) 2020-2029 by Jun Mo, All rights reserved.
//
//----------------------------------------------------------------------

#include "NavBit.h"

// following table generate by MATLAB code:
// encdata=(0:255)';
// bindata=dec2bin(encdata,8)-'0';
// for i=1:256
//	G11=mod(bindata(i,1)+bindata(i,4)+bindata(i,5)+bindata(i,6)+bindata(i,7),2);
//	G21=mod(bindata(i,1)+bindata(i,2)+bindata(i,4)+bindata(i,5)+bindata(i,7),2);
//	G10=mod(bindata(i,2)+bindata(i,5)+bindata(i,6)+bindata(i,7)+bindata(i,8),2);
//	G20=mod(bindata(i,2)+bindata(i,3)+bindata(i,5)+bindata(i,6)+bindata(i,8),2);
//	encbits(i,:)=[G21 G11 G20 G10 G11 G21 G10 G20];
// end
// enchex=encbits(:,1)*128+encbits(:,2)*64+encbits(:,3)*32+encbits(:,4)*16+encbits(:,5)*8+encbits(:,6)*4+encbits(:,7)*2+encbits(:,8);
// enchex=dec2hex(enchex,2);
const unsigned char NavBit::ConvEncodeTable[256] = {
0x00, 0x33, 0xde, 0xed, 0x7b, 0x48, 0xa5, 0x96, 0xff, 0xcc, 0x21, 0x12, 0x84, 0xb7, 0x5a, 0x69, 
0xcc, 0xff, 0x12, 0x21, 0xb7, 0x84, 0x69, 0x5a, 0x33, 0x00, 0xed, 0xde, 0x48, 0x7b, 0x96, 0xa5, 
0x21, 0x12, 0xff, 0xcc, 0x5a, 0x69, 0x84, 0xb7, 0xde, 0xed, 0x00, 0x33, 0xa5, 0x96, 0x7b, 0x48, 
0xed, 0xde, 0x33, 0x00, 0x96, 0xa5, 0x48, 0x7b, 0x12, 0x21, 0xcc, 0xff, 0x69, 0x5a, 0xb7, 0x84, 
0xb7, 0x84, 0x69, 0x5a, 0xcc, 0xff, 0x12, 0x21, 0x48, 0x7b, 0x96, 0xa5, 0x33, 0x00, 0xed, 0xde, 
0x7b, 0x48, 0xa5, 0x96, 0x00, 0x33, 0xde, 0xed, 0x84, 0xb7, 0x5a, 0x69, 0xff, 0xcc, 0x21, 0x12, 
0x96, 0xa5, 0x48, 0x7b, 0xed, 0xde, 0x33, 0x00, 0x69, 0x5a, 0xb7, 0x84, 0x12, 0x21, 0xcc, 0xff, 
0x5a, 0x69, 0x84, 0xb7, 0x21, 0x12, 0xff, 0xcc, 0xa5, 0x96, 0x7b, 0x48, 0xde, 0xed, 0x00, 0x33, 
0xcc, 0xff, 0x12, 0x21, 0xb7, 0x84, 0x69, 0x5a, 0x33, 0x00, 0xed, 0xde, 0x48, 0x7b, 0x96, 0xa5, 
0x00, 0x33, 0xde, 0xed, 0x7b, 0x48, 0xa5, 0x96, 0xff, 0xcc, 0x21, 0x12, 0x84, 0xb7, 0x5a, 0x69, 
0xed, 0xde, 0x33, 0x00, 0x96, 0xa5, 0x48, 0x7b, 0x12, 0x21, 0xcc, 0xff, 0x69, 0x5a, 0xb7, 0x84, 
0x21, 0x12, 0xff, 0xcc, 0x5a, 0x69, 0x84, 0xb7, 0xde, 0xed, 0x00, 0x33, 0xa5, 0x96, 0x7b, 0x48, 
0x7b, 0x48, 0xa5, 0x96, 0x00, 0x33, 0xde, 0xed, 0x84, 0xb7, 0x5a, 0x69, 0xff, 0xcc, 0x21, 0x12, 
0xb7, 0x84, 0x69, 0x5a, 0xcc, 0xff, 0x12, 0x21, 0x48, 0x7b, 0x96, 0xa5, 0x33, 0x00, 0xed, 0xde, 
0x5a, 0x69, 0x84, 0xb7, 0x21, 0x12, 0xff, 0xcc, 0xa5, 0x96, 0x7b, 0x48, 0xde, 0xed, 0x00, 0x33, 
0x96, 0xa5, 0x48, 0x7b, 0xed, 0xde, 0x33, 0x00, 0x69, 0x5a, 0xb7, 0x84, 0x12, 0x21, 0xcc, 0xff, 
};


const unsigned int NavBit::Crc24q[256] = {
	0x00000000u, 0x864CFB00u, 0x8AD50D00u, 0x0C99F600u, 0x93E6E100u, 0x15AA1A00u, 0x1933EC00u, 0x9F7F1700u, 
	0xA1813900u, 0x27CDC200u, 0x2B543400u, 0xAD18CF00u, 0x3267D800u, 0xB42B2300u, 0xB8B2D500u, 0x3EFE2E00u, 
	0xC54E8900u, 0x43027200u, 0x4F9B8400u, 0xC9D77F00u, 0x56A86800u, 0xD0E49300u, 0xDC7D6500u, 0x5A319E00u, 
	0x64CFB000u, 0xE2834B00u, 0xEE1ABD00u, 0x68564600u, 0xF7295100u, 0x7165AA00u, 0x7DFC5C00u, 0xFBB0A700u, 
	0x0CD1E900u, 0x8A9D1200u, 0x8604E400u, 0x00481F00u, 0x9F370800u, 0x197BF300u, 0x15E20500u, 0x93AEFE00u, 
	0xAD50D000u, 0x2B1C2B00u, 0x2785DD00u, 0xA1C92600u, 0x3EB63100u, 0xB8FACA00u, 0xB4633C00u, 0x322FC700u, 
	0xC99F6000u, 0x4FD39B00u, 0x434A6D00u, 0xC5069600u, 0x5A798100u, 0xDC357A00u, 0xD0AC8C00u, 0x56E07700u, 
	0x681E5900u, 0xEE52A200u, 0xE2CB5400u, 0x6487AF00u, 0xFBF8B800u, 0x7DB44300u, 0x712DB500u, 0xF7614E00u, 
	0x19A3D200u, 0x9FEF2900u, 0x9376DF00u, 0x153A2400u, 0x8A453300u, 0x0C09C800u, 0x00903E00u, 0x86DCC500u, 
	0xB822EB00u, 0x3E6E1000u, 0x32F7E600u, 0xB4BB1D00u, 0x2BC40A00u, 0xAD88F100u, 0xA1110700u, 0x275DFC00u, 
	0xDCED5B00u, 0x5AA1A000u, 0x56385600u, 0xD074AD00u, 0x4F0BBA00u, 0xC9474100u, 0xC5DEB700u, 0x43924C00u, 
	0x7D6C6200u, 0xFB209900u, 0xF7B96F00u, 0x71F59400u, 0xEE8A8300u, 0x68C67800u, 0x645F8E00u, 0xE2137500u, 
	0x15723B00u, 0x933EC000u, 0x9FA73600u, 0x19EBCD00u, 0x8694DA00u, 0x00D82100u, 0x0C41D700u, 0x8A0D2C00u, 
	0xB4F30200u, 0x32BFF900u, 0x3E260F00u, 0xB86AF400u, 0x2715E300u, 0xA1591800u, 0xADC0EE00u, 0x2B8C1500u, 
	0xD03CB200u, 0x56704900u, 0x5AE9BF00u, 0xDCA54400u, 0x43DA5300u, 0xC596A800u, 0xC90F5E00u, 0x4F43A500u, 
	0x71BD8B00u, 0xF7F17000u, 0xFB688600u, 0x7D247D00u, 0xE25B6A00u, 0x64179100u, 0x688E6700u, 0xEEC29C00u, 
	0x3347A400u, 0xB50B5F00u, 0xB992A900u, 0x3FDE5200u, 0xA0A14500u, 0x26EDBE00u, 0x2A744800u, 0xAC38B300u, 
	0x92C69D00u, 0x148A6600u, 0x18139000u, 0x9E5F6B00u, 0x01207C00u, 0x876C8700u, 0x8BF57100u, 0x0DB98A00u, 
	0xF6092D00u, 0x7045D600u, 0x7CDC2000u, 0xFA90DB00u, 0x65EFCC00u, 0xE3A33700u, 0xEF3AC100u, 0x69763A00u, 
	0x57881400u, 0xD1C4EF00u, 0xDD5D1900u, 0x5B11E200u, 0xC46EF500u, 0x42220E00u, 0x4EBBF800u, 0xC8F70300u, 
	0x3F964D00u, 0xB9DAB600u, 0xB5434000u, 0x330FBB00u, 0xAC70AC00u, 0x2A3C5700u, 0x26A5A100u, 0xA0E95A00u, 
	0x9E177400u, 0x185B8F00u, 0x14C27900u, 0x928E8200u, 0x0DF19500u, 0x8BBD6E00u, 0x87249800u, 0x01686300u, 
	0xFAD8C400u, 0x7C943F00u, 0x700DC900u, 0xF6413200u, 0x693E2500u, 0xEF72DE00u, 0xE3EB2800u, 0x65A7D300u, 
	0x5B59FD00u, 0xDD150600u, 0xD18CF000u, 0x57C00B00u, 0xC8BF1C00u, 0x4EF3E700u, 0x426A1100u, 0xC426EA00u, 
	0x2AE47600u, 0xACA88D00u, 0xA0317B00u, 0x267D8000u, 0xB9029700u, 0x3F4E6C00u, 0x33D79A00u, 0xB59B6100u, 
	0x8B654F00u, 0x0D29B400u, 0x01B04200u, 0x87FCB900u, 0x1883AE00u, 0x9ECF5500u, 0x9256A300u, 0x141A5800u, 
	0xEFAAFF00u, 0x69E60400u, 0x657FF200u, 0xE3330900u, 0x7C4C1E00u, 0xFA00E500u, 0xF6991300u, 0x70D5E800u, 
	0x4E2BC600u, 0xC8673D00u, 0xC4FECB00u, 0x42B23000u, 0xDDCD2700u, 0x5B81DC00u, 0x57182A00u, 0xD154D100u, 
	0x26359F00u, 0xA0796400u, 0xACE09200u, 0x2AAC6900u, 0xB5D37E00u, 0x339F8500u, 0x3F067300u, 0xB94A8800u, 
	0x87B4A600u, 0x01F85D00u, 0x0D61AB00u, 0x8B2D5000u, 0x14524700u, 0x921EBC00u, 0x9E874A00u, 0x18CBB100u, 
	0xE37B1600u, 0x6537ED00u, 0x69AE1B00u, 0xEFE2E000u, 0x709DF700u, 0xF6D10C00u, 0xFA48FA00u, 0x7C040100u, 
	0x42FA2F00u, 0xC4B6D400u, 0xC82F2200u, 0x4E63D900u, 0xD11CCE00u, 0x57503500u, 0x5BC9C300u, 0xDD853800u
};

NavBit::NavBit()
{
}

NavBit::~NavBit()
{
}
int NavBit::roundi(double data)
{
	if (data >= 0)
		return (int)(data + 0.5);
	else
		return (int)(data - 0.5);
}

int NavBit::roundu(double data)
{
	return (unsigned int)(data + 0.5);
}

double NavBit::UnscaleDouble(double value, int scale)
{
	DOUBLE_INT_UNION data;

	data.d_data = value;
	data.i_data[1] -= (scale << 20);
	return data.d_data;
}

int NavBit::UnscaleInt(double value, int scale)
{
	long long int long_value = UnscaleLong(value, scale);
	return (int)long_value;
}

unsigned int NavBit::UnscaleUint(double value, int scale)
{
	unsigned long long int long_value = UnscaleULong(value, scale);
	return (unsigned int)long_value;
}

long long int NavBit::UnscaleLong(double value, int scale)
{
	DOUBLE_INT_UNION *data = (DOUBLE_INT_UNION *)(&value);
	long long int fraction;
	int sign;

	sign = (data->i_data[1] & 0x80000000);
	fraction = (long long int)UnscaleULong(value, scale);
	return (sign ? -fraction : fraction);
}

unsigned long long int NavBit::UnscaleULong(double value, int scale)
{
	DOUBLE_INT_UNION *data = (DOUBLE_INT_UNION *)(&value);
	unsigned long long int fraction;
	int exp, shift;

	exp = ((data->i_data[1] & 0x7ff00000) >> 20);
	data->i_data[1] &= 0xfffff;	// clear sign/exp
	fraction = *(long long *)(&value);
	if (exp == 0 && fraction == 0)
		return 0;
	fraction |= 0x10000000000000LL;	// add 1. part
	shift = 1074 - exp + scale;
	fraction += (1LL << shift);	// round
	fraction >>= (shift + 1);
	return fraction;
}

// put bit in Data from MSB ot LSB into BitStream, bit order from bit(BitNumber-1) to bit(0) of Data
int NavBit::AssignBits(unsigned int Data, int BitNumber, int BitStream[])
{
	int i;

	Data <<= (32 - BitNumber);
	for (i = 0; i < BitNumber; i++)
	{
		BitStream[i] = (Data & 0x80000000) ? 1 : 0;
		Data <<= 1;
	}

	return BitNumber;
}

// do 2bit convolution encode at the same time
// EncodeBits bit 7~2 is current state
// EncodeBits bit1 and bit0 are new incomming bits with bit1 comes first
// return value are generated encoded bit with following order
// G21 G11 G20 G10 G11 G21 G10 G20 (G11 and G21 are encoded bits using bit1, G10 and G20 are encoded bits using bit0)
// so 4MSB of return value are 4 encoded bits with G2/G1 order
// 4LSB of return value are 4 encoded bits with G1/G2 order
unsigned char NavBit::ConvolutionEncode(unsigned char EncodeBits)
{
	return ConvEncodeTable[EncodeBits];
}

// Length is number of bits in BitStream to do CRC24Q encode
// input BitStream filled with MSB first and start from index 0
// if encoded bits does not fit all bits in BitStream (Length is not multiple of 32)
// 0s need to be filled first (at MSBs of BitStream[0]) to make sure last encoded bits
// in bit0 of last index of BitStream array (this is because encoding 0 into all zero
// state CRC24Q encode does not change encoder status)
unsigned int NavBit::Crc24qEncode(unsigned int *BitStream, int Length)
{
	int i, ByteNum;
	unsigned int Data, crc_result = 0;

	ByteNum = ((Length + 31) / 32) * 4;
	Data = BitStream[0];
	for (i = 0; i < ByteNum; i ++)
	{
		crc_result = (crc_result << 8) ^ Crc24q[(Data >> 24) ^ (unsigned char)(crc_result >> 16)];
		Data <<= 8;
		if ((i & 3) == 3)	// move to next bit
			Data = BitStream[(i >> 2) + 1];
	}

	return crc_result & 0xffffff;
}
