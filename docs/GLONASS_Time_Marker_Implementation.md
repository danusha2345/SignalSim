# Реализация временной метки ГЛОНАСС

## Дата: 13 января 2025

## Обзор
Документ описывает техническую реализацию временной метки (укороченной ПСП) для сигналов ГЛОНАСС FDMA (G1/G2), которая была добавлена для обеспечения совместимости со стандартом ICD ГЛОНАСС.

## Проблема
Приёмники ГЛОНАСС не могли обнаружить сигналы из-за отсутствия обязательной временной метки в начале каждой строки навигационного сообщения. Без временной метки приёмники не могут синхронизироваться с потоком данных.

## Техническое решение

### 1. Структура временной метки
- **Длина**: 30 бит
- **Значение**: 0x1B8593A0 (фиксированная укороченная ПСП)
- **Скорость передачи**: 100 бит/с (10 мс на бит)
- **Общая длительность**: 300 мс

### 2. Структура строки ГЛОНАСС
```
Полная строка (2000 мс):
├── Временная метка (300 мс): 30 бит × 10 мс/бит
└── Навигационные данные (1700 мс): 100 бит × 17 мс/бит
```

### 3. Изменения в коде

#### GNavBit.h
```cpp
// Добавлен метод для получения временной метки
static void GetTimeMarker(int *TimeMarkerBits);
```

#### GNavBit.cpp
```cpp
void GNavBit::GetTimeMarker(int *TimeMarkerBits)
{
    const unsigned int TIME_MARK = 0x1B8593A0;
    const int MARK_LENGTH = 30;
    
    for (int i = 0; i < MARK_LENGTH; i++)
    {
        TimeMarkerBits[i] = (TIME_MARK >> (29 - i)) & 1;
    }
}
```

#### SatelliteSignal.h
```cpp
// Добавлены члены класса для поддержки временной метки
int TimeMarkerBits[30];     // 30-битная временная метка
bool IsInTimeMarker;        // флаг передачи временной метки

// Добавлены члены для вторичного кода (требуется для компиляции)
const unsigned int *SecondaryCode;
int SecondaryLength;
```

#### SatelliteSignal.cpp
Основная логика обработки временной метки в методе `GetSatelliteSignal()`:

```cpp
// Для ГЛОНАСС FDMA обработка временной метки
if (SatSystem == GlonassSystem && (SatSignal == SIGNAL_INDEX_G1 || SatSignal == SIGNAL_INDEX_G2))
{
    int StringPosition = TransmitTime.MilliSeconds % 2000;
    
    if (StringPosition < 300)  // Передаём временную метку
    {
        // Загрузить временную метку в начале новой строки
        if (StringPosition == 0)
        {
            GNavBit::GetTimeMarker(TimeMarkerBits);
        }
        
        IsInTimeMarker = true;
        int TimeMarkerBitIndex = StringPosition / 10;
        DataBit = (TimeMarkerBitIndex < 30) ? (TimeMarkerBits[TimeMarkerBitIndex] ? -1 : 1) : 1;
        
        DataSignal = complex_number((double)DataBit, 0);
        PilotSignal = complex_number(0, 0);
        return TRUE;
    }
    else  // Передаём навигационные данные
    {
        IsInTimeMarker = false;
        // Корректировка времени и позиции бита для навигационных данных
        BitNumber = (StringPosition - 300) * 100 / 1700;
        BitPos = ((StringPosition - 300) % 17) / Attribute->CodeLength;
    }
}
```

### 4. Ключевые особенности реализации

1. **Синхронизация**: Временная метка загружается только в начале каждой новой строки (когда StringPosition == 0)

2. **Модуляция**: Временная метка модулируется как обычные данные (BPSK), где:
   - Бит 0 → амплитуда +1
   - Бит 1 → амплитуда -1

3. **Переход к навигационным данным**: После 300 мс автоматически переключается на передачу навигационных данных с корректировкой временных параметров

4. **Совместимость**: Реализация полностью совместима с существующей архитектурой модуляции сигналов

### 5. Результаты

После внедрения временной метки:
- Генерация сигналов ГЛОНАСС G1/G2 работает корректно
- Структура сигнала соответствует стандарту ICD ГЛОНАСС
- Приёмники теперь могут синхронизироваться с сигналом и декодировать навигационные данные

### 6. Тестирование

Успешная генерация подтверждена запуском:
```bash
./IFdataGen/IFdataGen -conf presets/GLO_G1_only.json -duration 180 -o generated_files/GLO_G1_only_3min.C8
```

Программа корректно:
- Находит видимые спутники ГЛОНАСС
- Генерирует сигналы с временными метками
- Создаёт выходной файл без ошибок

## Заключение

Реализация временной метки устраняет последнюю критическую проблему совместимости сигналов ГЛОНАСС со стандартом. Теперь генерируемые сигналы полностью соответствуют требованиям ICD ГЛОНАСС и могут быть обработаны стандартными приёмниками.