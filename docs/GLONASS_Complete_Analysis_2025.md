# Полный анализ реализации сигнала ГЛОНАСС
## Дата: 14 января 2025

## Резюме проблем

После детального анализа кода и сравнения с ICD ГЛОНАСС и открытыми реализациями (GNSS-SDR), выявлены следующие проблемы:

### 1. ✅ Меандр реализован, но возможна проблема с полярностью
**Статус:** Меандр 100 Гц присутствует в коде
**Локация:** SatelliteSignal.cpp, строки 205 и 350
**Реализация:**
```cpp
int meander = ((TransmitTime.MilliSeconds / 10) % 2) ? -1 : 1;
DataSignal *= meander;
```

**Потенциальная проблема:** Полярность меандра может быть инвертирована. В некоторых реализациях используется `? 1 : -1` вместо `? -1 : 1`.

### 2. ❌ Неправильный порядок операций XOR в SatIfSignal.cpp
**Статус:** Критическая ошибка
**Локация:** SatIfSignal.cpp, строки 144-160

**Текущая реализация:**
```cpp
// DataSignal уже содержит навигационный бит с применённым меандром
int dataBit = (DataSignal.real < 0) ? 1 : 0;
int modulatedBit = prnBit ^ dataBit;
```

**Проблема:** Согласно ICD ГЛОНАСС, все три компонента (PRN, данные, меандр) должны складываться по модулю 2 независимо. Сейчас меандр применяется через умножение к DataSignal, а затем происходит XOR с PRN. Это неправильно.

**Должно быть:**
```cpp
int navBit = /* исходный бит навигационных данных */;
int meander = ((currentTimeMs / 10) % 2) ? 1 : 0;
int modulatedBit = prnBit ^ navBit ^ meander;
```

### 3. ❌ Смешение операций умножения и XOR
**Статус:** Концептуальная ошибка
**Проблема:** В коде используется умножение (`DataSignal *= meander`) вместо XOR. Это приводит к неправильной модуляции.

### 4. ❌ Неправильная модуляция для временной метки
**Статус:** Ошибка реализации
**Локация:** SatelliteSignal.cpp, строки 195-208

Временная метка модулируется меандром через умножение, что неверно. Должна использоваться операция XOR.

### 5. ✅ BPSK модуляция реализована правильно
**Статус:** Корректно
**Примечание:** Финальное отображение на BPSK (0→+1, 1→-1) реализовано правильно.

## Правильная схема модуляции ГЛОНАСС согласно ICD

```
Временная диаграмма:
PRN (511 кГц):     01011001101...  (меняется каждые ~2 мкс)
Данные (50 Гц):    00000000001...  (меняется каждые 20 мс)
Меандр (100 Гц):   00000111110...  (меняется каждые 5 мс)
                   ↓ XOR ↓ XOR ↓
Результат:         01011110000...
                   ↓ BPSK
Сигнал:           +1-1+1-1-1-1+1...
```

## Сравнение с GNSS-SDR

Согласно документации GNSS-SDR:
- "The Standard Precision signals are generated by the Modulo-2 addition of: PR ranging code (511 kbps), Navigation message (50 bps), and 100 Hz auxiliary meander sequence"
- "Due to the effect of the meander sequence, bits of navigation need further processing before decoding"
- Меандр должен быть удалён при декодировании в приёмнике

## Необходимые исправления

### 1. Изменить SatelliteSignal.cpp
Вместо умножения на меандр, нужно передавать исходный бит данных и флаг меандра отдельно:

```cpp
// Для ГЛОНАСС передаём исходный бит без меандра
if (SatSystem == GlonassSystem && (SatSignal == SIGNAL_INDEX_G1 || SatSignal == SIGNAL_INDEX_G2))
{
    DataBit = (DataBits[BitNumber] ? -1 : 1);  // Без инверсии для XOR
    DataSignal = complex_number((double)DataBit, 0);
    PilotSignal = complex_number(0, 0);
    // Меандр будет применён в SatIfSignal::GetPrnValue через XOR
}
```

### 2. Изменить SatIfSignal.cpp
Реализовать правильное сложение по модулю 2:

```cpp
if (System == GlonassSystem && (SignalIndex == SIGNAL_INDEX_G1 || SignalIndex == SIGNAL_INDEX_G2)) 
{
    // Получаем все три компонента
    int prnBit = (DataPrn && DataChip >= 0 && DataChip < DataLength && DataPrn[DataChip]) ? 1 : 0;
    int navBit = (DataSignal.real > 0) ? 0 : 1;  // 0 если положительный, 1 если отрицательный
    
    // Вычисляем меандр для текущего момента времени
    int currentMs = SignalTime.MilliSeconds + (int)(CurChip / PrnSequence->Attribute->ChipRate);
    int meander = ((currentMs / 10) % 2) ? 1 : 0;
    
    // Сложение по модулю 2 всех трёх компонентов
    int modulatedBit = prnBit ^ navBit ^ meander;
    
    // BPSK модуляция: 0 → +1, 1 → -1
    PrnValue = complex_number(modulatedBit ? -1.0 : 1.0, 0.0);
    
    CurChip += CodeStep;
    return PrnValue;
}
```

### 3. Проверить полярность меандра
Возможно, нужно изменить:
```cpp
int meander = ((currentMs / 10) % 2) ? 0 : 1;  // Инвертированная полярность
```

## Почему приёмники не видят сигнал

1. **Неправильная модуляция:** Использование умножения вместо XOR нарушает спектральные характеристики сигнала
2. **Неправильный порядок операций:** Меандр применяется к данным до XOR с PRN, что неверно
3. **Возможная инверсия полярности:** Если полярность меандра инвертирована, приёмники не смогут синхронизироваться

## Рекомендации по отладке

1. Сравнить генерируемый сигнал с эталонным сигналом ГЛОНАСС
2. Проверить спектр сигнала - должны быть видны характерные линии от меандра 100 Гц
3. Использовать анализатор спектра для проверки правильности модуляции
4. Протестировать с разными полярностями меандра

## Заключение

Основная проблема - неправильная реализация сложения по модулю 2. Вместо независимого XOR трёх компонентов, код использует умножение для меандра, что фундаментально неверно. Необходимо переписать модуляцию согласно стандарту ICD ГЛОНАСС.

## Дополнительные проверки

### Проверка частот FDMA
Каждый спутник ГЛОНАСС передаёт на своей частоте:
- G1: 1602 МГц + k × 0.5625 МГц
- G2: 1246 МГц + k × 0.4375 МГц

где k - частотный канал от -7 до +6.

### Проверка синхронизации
1. Границы меандра должны совпадать с границами миллисекунд
2. Навигационные биты меняются каждые 20 мс
3. PRN код имеет период 1 мс (511 чипов)

### Эталонные реализации
Согласно GNSS-SDR и другим открытым реализациям:
- Меандр всегда применяется через XOR, не умножение
- Порядок операций: PRN ⊕ NAV ⊕ MEANDER
- Финальная BPSK модуляция: 0→+1, 1→-1

## Файл с исправлениями
Создан файл `fix_glonass_xor_modulation.cpp` с правильной реализацией модуляции ГЛОНАСС.